<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <title>Cupid's Arrow</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            user-select: none;
            -webkit-user-select: none;
            -webkit-touch-callout: none;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(to bottom, #FFE5EC 0%, #FFB3C1 100%);
            overflow: hidden;
            position: fixed;
            width: 100%;
            height: 100%;
            touch-action: none;
        }

        #game-container {
            position: relative;
            width: 100vw;
            height: 100vh;
            overflow: hidden;
        }

        #game-canvas {
            display: block;
            image-rendering: crisp-edges;
            image-rendering: pixelated;
        }

        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 10;
        }

        #score-display {
            position: absolute;
            top: 20px;
            left: 20px;
            font-size: 24px;
            font-weight: bold;
            color: #FF4458;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.2);
        }

        #combo-display {
            position: absolute;
            top: 60px;
            left: 20px;
            font-size: 18px;
            font-weight: bold;
            color: #FF6B6B;
            opacity: 0;
            transition: opacity 0.3s;
        }

        #level-display {
            position: absolute;
            top: 20px;
            right: 20px;
            font-size: 20px;
            font-weight: bold;
            color: #FF4458;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.2);
        }

        #arrow-selector {
            position: absolute;
            bottom: 20px;
            right: 20px;
            display: flex;
            gap: 10px;
            pointer-events: all;
        }

        .arrow-type {
            width: 50px;
            height: 50px;
            border-radius: 25px;
            background: rgba(255,255,255,0.9);
            border: 3px solid #FF4458;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            cursor: pointer;
            transition: all 0.3s;
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
        }

        .arrow-type.selected {
            background: #FF4458;
            transform: scale(1.2);
        }

        .arrow-type:active {
            transform: scale(0.95);
        }

        #power-meter {
            position: absolute;
            bottom: 100px;
            left: 50%;
            transform: translateX(-50%);
            width: 200px;
            height: 20px;
            background: rgba(255,255,255,0.3);
            border: 2px solid #FF4458;
            border-radius: 10px;
            overflow: hidden;
            opacity: 0;
            transition: opacity 0.3s;
            pointer-events: none;
        }

        #power-fill {
            height: 100%;
            background: linear-gradient(to right, #FFB3C1, #FF4458);
            width: 0%;
            transition: width 0.1s;
        }

        .floating-heart {
            position: absolute;
            font-size: 30px;
            pointer-events: none;
            animation: float-up 2s ease-out forwards;
            z-index: 100;
        }

        @keyframes float-up {
            0% {
                transform: translateY(0) scale(0);
                opacity: 1;
            }
            50% {
                transform: translateY(-30px) scale(1.2);
            }
            100% {
                transform: translateY(-80px) scale(0.8);
                opacity: 0;
            }
        }

        #menu {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(255,255,255,0.95);
            padding: 40px;
            border-radius: 20px;
            text-align: center;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
            z-index: 1000;
            pointer-events: all;
        }

        #menu h1 {
            color: #FF4458;
            font-size: 48px;
            margin-bottom: 20px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.1);
        }

        #menu button {
            background: #FF4458;
            color: white;
            border: none;
            padding: 15px 40px;
            font-size: 24px;
            font-weight: bold;
            border-radius: 30px;
            cursor: pointer;
            margin: 10px;
            transition: all 0.3s;
            box-shadow: 0 4px 15px rgba(255,68,88,0.4);
        }

        #menu button:hover {
            transform: scale(1.05);
            box-shadow: 0 6px 20px rgba(255,68,88,0.6);
        }

        #menu button:active {
            transform: scale(0.95);
        }

        .hidden {
            display: none !important;
        }

        #wind-indicator {
            position: absolute;
            top: 100px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 16px;
            color: #FF4458;
            background: rgba(255,255,255,0.8);
            padding: 5px 15px;
            border-radius: 20px;
            display: flex;
            align-items: center;
            gap: 10px;
            opacity: 0.8;
        }

        .achievement {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(255,255,255,0.95);
            padding: 20px 40px;
            border-radius: 15px;
            font-size: 24px;
            font-weight: bold;
            color: #FF4458;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
            z-index: 200;
            animation: achievement-pop 2s ease-out forwards;
            pointer-events: none;
        }

        @keyframes achievement-pop {
            0% {
                transform: translate(-50%, -50%) scale(0);
                opacity: 0;
            }
            20% {
                transform: translate(-50%, -50%) scale(1.2);
                opacity: 1;
            }
            80% {
                transform: translate(-50%, -50%) scale(1);
                opacity: 1;
            }
            100% {
                transform: translate(-50%, -50%) scale(1);
                opacity: 0;
            }
        }
    </style>
</head>
<body>
    <div id="game-container">
        <canvas id="game-canvas"></canvas>
        <div id="ui-layer">
            <div id="score-display">Score: 0</div>
            <div id="combo-display">Combo x1</div>
            <div id="level-display">Park</div>
            <div id="wind-indicator">üå¨Ô∏è Wind: 0</div>
            <div id="power-meter">
                <div id="power-fill"></div>
            </div>
            <div id="arrow-selector">
                <div class="arrow-type selected" data-type="normal">üíò</div>
                <div class="arrow-type" data-type="golden">‚≠ê</div>
                <div class="arrow-type" data-type="ice">‚ùÑÔ∏è</div>
            </div>
        </div>
        <div id="menu">
            <h1>üíï Cupid's Arrow üíï</h1>
            <p style="margin-bottom: 30px; color: #666;">Match hearts, spread love!</p>
            <button onclick="startGame()">Play</button>
            <button onclick="showInstructions()">How to Play</button>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('game-canvas');
        const ctx = canvas.getContext('2d');
        const scoreDisplay = document.getElementById('score-display');
        const comboDisplay = document.getElementById('combo-display');
        const levelDisplay = document.getElementById('level-display');
        const windIndicator = document.getElementById('wind-indicator');
        const powerMeter = document.getElementById('power-meter');
        const powerFill = document.getElementById('power-fill');
        const menu = document.getElementById('menu');
        const arrowSelector = document.getElementById('arrow-selector');

        // Audio context for sounds
        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();

        // Game state
        let gameState = {
            score: 0,
            combo: 1,
            level: 0,
            arrowType: 'normal',
            isAiming: false,
            aimStart: null,
            aimCurrent: null,
            power: 0,
            wind: 0,
            particles: [],
            arrows: [],
            people: [],
            matches: [],
            hearts: [],
            clouds: [],
            birds: [],
            lastMatchTime: 0,
            gameRunning: false,
            cupidPos: { x: 0, y: 0 },
            cupidVel: { y: 0 }
        };

        // Levels configuration
        const levels = [
            {
                name: 'Park',
                background: '#87CEEB',
                ground: '#90EE90',
                peopleCount: 8,
                obstacles: ['tree', 'bench'],
                windRange: [-0.5, 0.5]
            },
            {
                name: 'Caf√©',
                background: '#DEB887',
                ground: '#8B4513',
                peopleCount: 10,
                obstacles: ['table', 'plant'],
                windRange: [-0.3, 0.3]
            },
            {
                name: 'Beach',
                background: '#87CEEB',
                ground: '#F4A460',
                peopleCount: 12,
                obstacles: ['umbrella', 'wave'],
                windRange: [-1, 1]
            },
            {
                name: 'City',
                background: '#778899',
                ground: '#696969',
                peopleCount: 15,
                obstacles: ['building', 'car'],
                windRange: [-1.5, 1.5]
            }
        ];

        // Person types with compatibility
        const personTypes = [
            { emoji: 'üë®', traits: ['sporty', 'outgoing'], color: '#4A90E2' },
            { emoji: 'üë©', traits: ['artistic', 'calm'], color: '#E24A90' },
            { emoji: 'üßë', traits: ['intellectual', 'quiet'], color: '#90E24A' },
            { emoji: 'üë®‚Äçü¶±', traits: ['musical', 'energetic'], color: '#E2904A' },
            { emoji: 'üë©‚Äçü¶∞', traits: ['adventurous', 'bold'], color: '#904AE2' },
            { emoji: 'üßë‚Äçü¶≥', traits: ['wise', 'patient'], color: '#4AE290' }
        ];

        // Initialize canvas size
        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            if (gameState.gameRunning) {
                gameState.cupidPos = { x: canvas.width / 2, y: canvas.height - 150 };
            }
        }

        // Sound effects
        function playSound(type) {
            const oscillator = audioCtx.createOscillator();
            const gainNode = audioCtx.createGain();
            
            oscillator.connect(gainNode);
            gainNode.connect(audioCtx.destination);
            
            // Start the oscillator first
            oscillator.start(audioCtx.currentTime);
            
            switch(type) {
                case 'shoot':
                    oscillator.frequency.setValueAtTime(800, audioCtx.currentTime);
                    oscillator.frequency.exponentialRampToValueAtTime(400, audioCtx.currentTime + 0.1);
                    gainNode.gain.setValueAtTime(0.3, audioCtx.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.1);
                    oscillator.stop(audioCtx.currentTime + 0.1);
                    break;
                case 'hit':
                    oscillator.frequency.setValueAtTime(1200, audioCtx.currentTime);
                    oscillator.frequency.exponentialRampToValueAtTime(1600, audioCtx.currentTime + 0.05);
                    gainNode.gain.setValueAtTime(0.2, audioCtx.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.05);
                    oscillator.stop(audioCtx.currentTime + 0.05);
                    break;
                case 'match':
                    oscillator.frequency.setValueAtTime(523.25, audioCtx.currentTime); // C5
                    oscillator.frequency.setValueAtTime(659.25, audioCtx.currentTime + 0.1); // E5
                    oscillator.frequency.setValueAtTime(783.99, audioCtx.currentTime + 0.2); // G5
                    gainNode.gain.setValueAtTime(0.3, audioCtx.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.3);
                    oscillator.stop(audioCtx.currentTime + 0.3);
                    break;
                case 'powerup':
                    oscillator.frequency.setValueAtTime(440, audioCtx.currentTime);
                    oscillator.frequency.exponentialRampToValueAtTime(880, audioCtx.currentTime + 0.2);
                    gainNode.gain.setValueAtTime(0.2, audioCtx.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.2);
                    oscillator.stop(audioCtx.currentTime + 0.2);
                    break;
            }
        }

        // Create floating heart effect
        function createFloatingHeart(x, y) {
            const heart = document.createElement('div');
            heart.className = 'floating-heart';
            heart.textContent = 'üíï';
            heart.style.left = x + 'px';
            heart.style.top = y + 'px';
            document.getElementById('ui-layer').appendChild(heart);
            
            setTimeout(() => heart.remove(), 2000);
        }

        // Show achievement
        function showAchievement(text) {
            const achievement = document.createElement('div');
            achievement.className = 'achievement';
            achievement.textContent = text;
            document.getElementById('ui-layer').appendChild(achievement);
            
            playSound('powerup');
            setTimeout(() => achievement.remove(), 2000);
        }

        // Calculate compatibility
        function calculateCompatibility(person1, person2) {
            const sharedTraits = person1.type.traits.filter(t => person2.type.traits.includes(t));
            const compatibility = sharedTraits.length / 2;
            
            // Special combos
            if (person1.type.emoji === person2.type.emoji) {
                return 0.3; // Same type has lower compatibility
            }
            
            return compatibility + 0.5; // Base compatibility
        }

        // Initialize level
        function initLevel() {
            const level = levels[gameState.level % levels.length];
            levelDisplay.textContent = level.name;
            gameState.people = [];
            gameState.matches = [];
            gameState.arrows = [];
            gameState.particles = [];
            gameState.hearts = [];
            gameState.clouds = [];
            gameState.birds = [];
            
            // Generate people
            for (let i = 0; i < level.peopleCount; i++) {
                const type = personTypes[Math.floor(Math.random() * personTypes.length)];
                const person = {
                    x: Math.random() * (canvas.width - 100) + 50,
                    y: canvas.height - 180 - Math.random() * 100,
                    vx: (Math.random() - 0.5) * 2,
                    vy: 0,
                    type: type,
                    state: 'walking',
                    stateTimer: 0,
                    direction: Math.random() > 0.5 ? 1 : -1,
                    matched: false,
                    frozen: false,
                    glowing: false,
                    personality: Math.random(), // Affects behavior
                    size: 30 + Math.random() * 10,
                    walkCycle: 0
                };
                gameState.people.push(person);
            }
            
            // Generate clouds
            for (let i = 0; i < 5; i++) {
                gameState.clouds.push({
                    x: Math.random() * canvas.width,
                    y: Math.random() * 200,
                    size: 40 + Math.random() * 30,
                    speed: 0.2 + Math.random() * 0.3
                });
            }
            
            // Generate birds
            for (let i = 0; i < 3; i++) {
                gameState.birds.push({
                    x: Math.random() * canvas.width,
                    y: 50 + Math.random() * 150,
                    vx: 1 + Math.random(),
                    vy: Math.sin(Date.now() * 0.001) * 0.5,
                    wingPhase: Math.random() * Math.PI * 2
                });
            }
            
            // Set wind
            const windRange = level.windRange;
            gameState.wind = windRange[0] + Math.random() * (windRange[1] - windRange[0]);
            windIndicator.innerHTML = `üå¨Ô∏è Wind: ${gameState.wind > 0 ? '‚Üí' : '‚Üê'} ${Math.abs(gameState.wind).toFixed(1)}`;
        }

        // Update game logic
        function update(deltaTime) {
            if (!gameState.gameRunning) return;
            
            const level = levels[gameState.level % levels.length];
            
            // Update cupid physics
            if (gameState.isAiming) {
                gameState.cupidVel.y *= 0.95; // Slow down when aiming
            } else {
                gameState.cupidVel.y += 0.3; // Gravity
            }
            gameState.cupidPos.y += gameState.cupidVel.y;
            
            // Cupid bounds
            if (gameState.cupidPos.y > canvas.height - 150) {
                gameState.cupidPos.y = canvas.height - 150;
                gameState.cupidVel.y = 0;
            }
            
            // Update people
            gameState.people.forEach(person => {
                if (person.matched || person.frozen) return;
                
                person.walkCycle += 0.1;
                
                // AI behavior based on personality
                person.stateTimer--;
                if (person.stateTimer <= 0) {
                    if (person.state === 'walking') {
                        if (Math.random() < 0.3) {
                            person.state = 'standing';
                            person.stateTimer = 60 + Math.random() * 120;
                            person.vx = 0;
                        } else {
                            person.direction *= -1;
                            person.stateTimer = 60 + Math.random() * 180;
                        }
                    } else {
                        person.state = 'walking';
                        person.stateTimer = 120 + Math.random() * 240;
                        person.vx = person.direction * (0.5 + person.personality * 1.5);
                    }
                }
                
                // Movement
                person.x += person.vx;
                
                // Bounds
                if (person.x < 30 || person.x > canvas.width - 30) {
                    person.direction *= -1;
                    person.vx = person.direction * (0.5 + person.personality * 1.5);
                    person.x = Math.max(30, Math.min(canvas.width - 30, person.x));
                }
            });
            
            // Update arrows
            gameState.arrows = gameState.arrows.filter(arrow => {
                arrow.x += arrow.vx;
                arrow.y += arrow.vy;
                arrow.vx += gameState.wind * 0.02; // Wind effect
                arrow.vy += 0.3; // Gravity
                arrow.rotation += 0.1;
                
                // Arrow trail particles
                if (Math.random() < 0.8) {
                    gameState.particles.push({
                        x: arrow.x,
                        y: arrow.y,
                        vx: (Math.random() - 0.5) * 2,
                        vy: (Math.random() - 0.5) * 2,
                        life: 30,
                        color: arrow.type === 'golden' ? '#FFD700' : arrow.type === 'ice' ? '#87CEEB' : '#FF69B4',
                        size: 3 + Math.random() * 3
                    });
                }
                
                // Check collisions with people
                let hit = false;
                gameState.people.forEach(person => {
                    if (person.matched) return;
                    
                    const dx = arrow.x - person.x;
                    const dy = arrow.y - person.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    
                    if (dist < person.size) {
                        hit = true;
                        playSound('hit');
                        
                        // Apply arrow effect
                        if (arrow.type === 'golden') {
                            person.glowing = true;
                            setTimeout(() => person.glowing = false, 5000);
                        } else if (arrow.type === 'ice') {
                            person.frozen = true;
                            setTimeout(() => person.frozen = false, 3000);
                        }
                        
                        // Find potential match
                        const potentialMatches = gameState.people.filter(p => 
                            p !== person && !p.matched && 
                            Math.abs(p.x - person.x) < 200
                        );
                        
                        if (potentialMatches.length > 0) {
                            let bestMatch = potentialMatches[0];
                            let bestScore = calculateCompatibility(person, bestMatch);
                            
                            potentialMatches.forEach(p => {
                                const score = calculateCompatibility(person, p);
                                if (score > bestScore) {
                                    bestScore = score;
                                    bestMatch = p;
                                }
                            });
                            
                            // Create match
                            person.matched = true;
                            bestMatch.matched = true;
                            
                            const match = {
                                person1: person,
                                person2: bestMatch,
                                score: Math.floor(bestScore * 100),
                                timer: 180,
                                x: (person.x + bestMatch.x) / 2,
                                y: (person.y + bestMatch.y) / 2
                            };
                            
                            gameState.matches.push(match);
                            
                            // Score calculation
                            const baseScore = 100 * bestScore;
                            const comboBonus = gameState.combo * 10;
                            const totalScore = Math.floor(baseScore + comboBonus);
                            
                            gameState.score += totalScore;
                            scoreDisplay.textContent = `Score: ${gameState.score}`;
                            
                            // Update combo
                            const now = Date.now();
                            if (now - gameState.lastMatchTime < 3000) {
                                gameState.combo++;
                                comboDisplay.textContent = `Combo x${gameState.combo}`;
                                comboDisplay.style.opacity = '1';
                            } else {
                                gameState.combo = 1;
                                comboDisplay.style.opacity = '0';
                            }
                            gameState.lastMatchTime = now;
                            
                            // Effects
                            playSound('match');
                            createFloatingHeart(match.x, match.y);
                            
                            // Create heart explosion
                            for (let i = 0; i < 20; i++) {
                                gameState.particles.push({
                                    x: match.x,
                                    y: match.y,
                                    vx: (Math.random() - 0.5) * 10,
                                    vy: (Math.random() - 0.5) * 10,
                                    life: 40,
                                    color: '#FF1493',
                                    size: 5 + Math.random() * 5
                                });
                            }
                            
                            // Achievements
                            if (gameState.combo === 5) {
                                showAchievement('5x Combo! Love Master!');
                            } else if (bestScore > 0.9) {
                                showAchievement('Perfect Match! üíï');
                            }
                        }
                    }
                });
                
                return !hit && arrow.y < canvas.height + 50;
            });
            
            // Update matches
            gameState.matches = gameState.matches.filter(match => {
                match.timer--;
                
                // Move matched people together
                const targetX = (match.person1.x + match.person2.x) / 2;
                match.person1.x += (targetX - match.person1.x) * 0.1;
                match.person2.x += (targetX - match.person2.x) * 0.1;
                
                // Floating hearts
                if (match.timer % 20 === 0) {
                    gameState.hearts.push({
                        x: match.x + (Math.random() - 0.5) * 40,
                        y: match.y,
                        vy: -1,
                        life: 60,
                        size: 15 + Math.random() * 10
                    });
                }
                
                return match.timer > 0;
            });
            
            // Update particles
            gameState.particles = gameState.particles.filter(particle => {
                particle.x += particle.vx;
                particle.y += particle.vy;
                particle.vy += 0.1;
                particle.life--;
                particle.size *= 0.95;
                return particle.life > 0;
            });
            
            // Update hearts
            gameState.hearts = gameState.hearts.filter(heart => {
                heart.y += heart.vy;
                heart.vy -= 0.02;
                heart.life--;
                return heart.life > 0;
            });
            
            // Update clouds
            gameState.clouds.forEach(cloud => {
                cloud.x += cloud.speed;
                if (cloud.x > canvas.width + cloud.size) {
                    cloud.x = -cloud.size;
                }
            });
            
            // Update birds
            gameState.birds.forEach(bird => {
                bird.x += bird.vx;
                bird.y += Math.sin(Date.now() * 0.002 + bird.wingPhase) * 0.5;
                bird.wingPhase += 0.1;
                
                if (bird.x > canvas.width + 50) {
                    bird.x = -50;
                    bird.y = 50 + Math.random() * 150;
                }
            });
            
            // Check level completion
            const unmatchedPeople = gameState.people.filter(p => !p.matched).length;
            if (unmatchedPeople === 0 || (unmatchedPeople === 1 && gameState.people.length % 2 === 1)) {
                gameState.level++;
                showAchievement(`Level Complete! Welcome to ${levels[gameState.level % levels.length].name}`);
                setTimeout(() => initLevel(), 2000);
            }
        }

        // Render game
        function render() {
            const level = levels[gameState.level % levels.length];
            
            // Clear canvas
            ctx.fillStyle = level.background;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Draw clouds
            ctx.fillStyle = 'rgba(255,255,255,0.7)';
            gameState.clouds.forEach(cloud => {
                ctx.beginPath();
                ctx.arc(cloud.x, cloud.y, cloud.size * 0.6, 0, Math.PI * 2);
                ctx.arc(cloud.x - cloud.size * 0.4, cloud.y, cloud.size * 0.4, 0, Math.PI * 2);
                ctx.arc(cloud.x + cloud.size * 0.4, cloud.y, cloud.size * 0.4, 0, Math.PI * 2);
                ctx.fill();
            });
            
            // Draw birds
            ctx.fillStyle = '#333';
            gameState.birds.forEach(bird => {
                ctx.save();
                ctx.translate(bird.x, bird.y);
                
                // Body
                ctx.beginPath();
                ctx.ellipse(0, 0, 8, 5, 0, 0, Math.PI * 2);
                ctx.fill();
                
                // Wings
                const wingAngle = Math.sin(bird.wingPhase) * 0.5;
                ctx.beginPath();
                ctx.moveTo(-5, 0);
                ctx.lineTo(-15, -5 * Math.cos(wingAngle));
                ctx.lineTo(-5, 2);
                ctx.fill();
                
                ctx.beginPath();
                ctx.moveTo(5, 0);
                ctx.lineTo(15, -5 * Math.cos(wingAngle));
                ctx.lineTo(5, 2);
                ctx.fill();
                
                ctx.restore();
            });
            
            // Draw ground
            ctx.fillStyle = level.ground;
            ctx.fillRect(0, canvas.height - 100, canvas.width, 100);
            
            // Draw obstacles based on level
            ctx.fillStyle = '#654321';
            if (level.obstacles.includes('tree')) {
                // Trees
                for (let i = 0; i < 3; i++) {
                    const x = (i + 1) * canvas.width / 4;
                    ctx.fillRect(x - 10, canvas.height - 180, 20, 80);
                    ctx.fillStyle = '#228B22';
                    ctx.beginPath();
                    ctx.arc(x, canvas.height - 180, 40, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.fillStyle = '#654321';
                }
            }
            
            // Draw people
            gameState.people.forEach(person => {
                ctx.save();
                ctx.translate(person.x, person.y);
                
                // Frozen effect
                if (person.frozen) {
                    ctx.fillStyle = 'rgba(135,206,235,0.5)';
                    ctx.beginPath();
                    ctx.arc(0, 0, person.size + 10, 0, Math.PI * 2);
                    ctx.fill();
                }
                
                // Glowing effect
                if (person.glowing) {
                    ctx.fillStyle = 'rgba(255,215,0,0.3)';
                    ctx.beginPath();
                    ctx.arc(0, 0, person.size + 15, 0, Math.PI * 2);
                    ctx.fill();
                }
                
                // Walking animation
                const walkOffset = Math.sin(person.walkCycle) * 3;
                ctx.translate(0, walkOffset);
                
                // Draw person
                ctx.font = `${person.size}px Arial`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(person.type.emoji, 0, 0);
                
                // Draw state indicator
                if (person.matched) {
                    ctx.fillText('üíï', 0, -person.size);
                }
                
                ctx.restore();
            });
            
            // Draw Cupid
            ctx.save();
            ctx.translate(gameState.cupidPos.x, gameState.cupidPos.y);
            
            // Wing animation
            const wingFlap = Math.sin(Date.now() * 0.01) * 0.2;
            
            // Left wing
            ctx.fillStyle = 'rgba(255,255,255,0.8)';
            ctx.beginPath();
            ctx.ellipse(-20, -10, 15, 25, -0.5 + wingFlap, 0, Math.PI * 2);
            ctx.fill();
            
            // Right wing
            ctx.beginPath();
            ctx.ellipse(20, -10, 15, 25, 0.5 - wingFlap, 0, Math.PI * 2);
            ctx.fill();
            
            // Body
            ctx.font = '40px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText('üëº', 0, 0);
            
            // Draw bow and aiming line
            if (gameState.isAiming && gameState.aimStart && gameState.aimCurrent) {
                const dx = gameState.aimCurrent.x - gameState.aimStart.x;
                const dy = gameState.aimCurrent.y - gameState.aimStart.y;
                const angle = Math.atan2(dy, dx);
                const power = Math.min(Math.sqrt(dx * dx + dy * dy) / 100, 1);
                
                ctx.strokeStyle = '#8B4513';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.arc(0, 0, 30, angle - 0.5, angle + 0.5);
                ctx.stroke();
                
                // Arrow preview
                ctx.strokeStyle = `rgba(255,69,185,${0.3 + power * 0.7})`;
                ctx.lineWidth = 2;
                ctx.setLineDash([5, 5]);
                ctx.beginPath();
                ctx.moveTo(0, 0);
                ctx.lineTo(dx * 0.5, dy * 0.5);
                ctx.stroke();
                ctx.setLineDash([]);
                
                // Update power meter
                powerMeter.style.opacity = '1';
                powerFill.style.width = (power * 100) + '%';
                gameState.power = power;
            } else {
                powerMeter.style.opacity = '0';
            }
            
            ctx.restore();
            
            // Draw arrows
            gameState.arrows.forEach(arrow => {
                ctx.save();
                ctx.translate(arrow.x, arrow.y);
                ctx.rotate(arrow.rotation);
                
                ctx.font = '25px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                
                if (arrow.type === 'golden') {
                    ctx.fillText('‚≠ê', 0, 0);
                } else if (arrow.type === 'ice') {
                    ctx.fillText('‚ùÑÔ∏è', 0, 0);
                } else {
                    ctx.fillText('üíò', 0, 0);
                }
                
                ctx.restore();
            });
            
            // Draw particles
            gameState.particles.forEach(particle => {
                ctx.fillStyle = particle.color + Math.floor(particle.life / 40 * 255).toString(16).padStart(2, '0');
                ctx.beginPath();
                ctx.arc(particle.x, particle.y, particle.size, 0, Math.PI * 2);
                ctx.fill();
            });
            
            // Draw floating hearts
            gameState.hearts.forEach(heart => {
                ctx.save();
                ctx.globalAlpha = heart.life / 60;
                ctx.font = `${heart.size}px Arial`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText('üíï', heart.x, heart.y);
                ctx.restore();
            });
        }

        // Game loop
        let lastTime = 0;
        function gameLoop(currentTime) {
            const deltaTime = currentTime - lastTime;
            lastTime = currentTime;
            
            update(deltaTime);
            render();
            
            requestAnimationFrame(gameLoop);
        }

        // Input handling
        function getInputPos(e) {
            const rect = canvas.getBoundingClientRect();
            if (e.touches) {
                return {
                    x: e.touches[0].clientX - rect.left,
                    y: e.touches[0].clientY - rect.top
                };
            }
            return {
                x: e.clientX - rect.left,
                y: e.clientY - rect.top
            };
        }

        function startAiming(e) {
            if (!gameState.gameRunning) return;
            e.preventDefault();
            
            const pos = getInputPos(e);
            gameState.isAiming = true;
            gameState.aimStart = pos;
            gameState.aimCurrent = pos;
            
            // Make cupid hover
            gameState.cupidVel.y = -5;
        }

        function updateAiming(e) {
            if (!gameState.isAiming) return;
            e.preventDefault();
            
            gameState.aimCurrent = getInputPos(e);
        }

        function endAiming(e) {
            if (!gameState.isAiming || !gameState.aimStart) return;
            e.preventDefault();
            
            const dx = gameState.aimCurrent.x - gameState.aimStart.x;
            const dy = gameState.aimCurrent.y - gameState.aimStart.y;
            const power = Math.min(Math.sqrt(dx * dx + dy * dy) / 100, 1);
            
            if (power > 0.1) {
                const arrow = {
                    x: gameState.cupidPos.x,
                    y: gameState.cupidPos.y,
                    vx: dx * 0.15 * power,
                    vy: dy * 0.15 * power,
                    rotation: 0,
                    type: gameState.arrowType
                };
                
                gameState.arrows.push(arrow);
                playSound('shoot');
                
                // Recoil
                gameState.cupidVel.y -= power * 3;
            }
            
            gameState.isAiming = false;
            gameState.aimStart = null;
            gameState.aimCurrent = null;
        }

        // Touch events
        canvas.addEventListener('touchstart', startAiming);
        canvas.addEventListener('touchmove', updateAiming);
        canvas.addEventListener('touchend', endAiming);
        canvas.addEventListener('touchcancel', endAiming);

        // Mouse events (for desktop testing)
        canvas.addEventListener('mousedown', startAiming);
        canvas.addEventListener('mousemove', updateAiming);
        canvas.addEventListener('mouseup', endAiming);
        canvas.addEventListener('mouseleave', endAiming);

        // Arrow type selection
        arrowSelector.querySelectorAll('.arrow-type').forEach(btn => {
            btn.addEventListener('click', (e) => {
                e.stopPropagation();
                arrowSelector.querySelectorAll('.arrow-type').forEach(b => b.classList.remove('selected'));
                btn.classList.add('selected');
                gameState.arrowType = btn.dataset.type;
                playSound('powerup');
            });
        });

        // Game control functions
        function startGame() {
            menu.classList.add('hidden');
            gameState.gameRunning = true;
            gameState.score = 0;
            gameState.combo = 1;
            gameState.level = 0;
            gameState.cupidPos = { x: canvas.width / 2, y: canvas.height - 150 };
            gameState.cupidVel = { y: 0 };
            scoreDisplay.textContent = 'Score: 0';
            
            initLevel();
            
            if (!audioCtx.state || audioCtx.state === 'suspended') {
                audioCtx.resume();
            }
        }

        function showInstructions() {
            menu.innerHTML = `
                <h1>How to Play</h1>
                <div style="text-align: left; max-width: 400px; margin: 0 auto;">
                    <p style="margin: 10px 0;"><strong>üèπ Aim & Shoot:</strong> Touch and drag to aim Cupid's bow</p>
                    <p style="margin: 10px 0;"><strong>üíï Match People:</strong> Hit people with arrows to create love matches</p>
                    <p style="margin: 10px 0;"><strong>üéØ Compatibility:</strong> Better matches give more points!</p>
                    <p style="margin: 10px 0;"><strong>‚ö° Combos:</strong> Make quick matches for combo multipliers</p>
                    <p style="margin: 10px 0;"><strong>üí´ Special Arrows:</strong></p>
                    <p style="margin: 10px 20px;">‚≠ê Golden: Makes people glow and attract matches</p>
                    <p style="margin: 10px 20px;">‚ùÑÔ∏è Ice: Freezes people in place temporarily</p>
                    <p style="margin: 10px 0;"><strong>üå¨Ô∏è Wind:</strong> Account for wind when aiming!</p>
                </div>
                <button onclick="location.reload()" style="margin-top: 20px;">Back</button>
            `;
        }

        // Initialize
        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();
        requestAnimationFrame(gameLoop);

        // Prevent default touch behaviors
        document.addEventListener('touchmove', (e) => e.preventDefault(), { passive: false });
        document.addEventListener('gesturestart', (e) => e.preventDefault());
    </script>
</body>
</html>
